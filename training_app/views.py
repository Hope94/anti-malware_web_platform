import os

from django.db.models import Sum, Count
from django.http import HttpResponse, Http404
from django.shortcuts import render, render_to_response
from django.urls import reverse_lazy
from django.contrib import messages
from django.shortcuts import redirect

from pfe_plateforme_web import settings
from django.views.generic import TemplateView, View, ListView, DetailView
from django.views.generic.edit import FormView
from training_app.forms import DatasetsForm, VectorSpaceForm, SelectDimensionsForm, TrainModelForm, SvmForm, RfForm, \
    KnnForm, StackingForm, BaggingForm, AdaboostForm, MlpForm, CnnForm
from main.forms import SearchApkForm
from main.search_engine import apk_search
from main.models import VectorSpace, Dataset, Apk, Feature, Model
from formtools.wizard.views import SessionWizardView
from main.vector_space_constractor import vectorizer
import db_manager
import time
from training_app import learner


# Create your views here.
class ModelGenerationView (TemplateView):
    template_name = 'training_app/model_generation.html'

    def get_context_data(self, **kwargs):
        context = super ().get_context_data (**kwargs)
        #context['result'] = generate_model.generateModel ()
        return context


class HomePage (ListView):
    template_name = "training_app/dashboard.html"
    model=Model
    queryset = Model.objects.order_by('-id')
    context_object_name='models'
    def get_context_data(self, **kwargs):
        context=super().get_context_data(**kwargs)
        """
         pieChart page
         """
        datasets=Dataset.objects.all()
        goodware=Dataset.objects.filter(apks__malignity=0).count()
        malware=Dataset.objects.filter(apks__malignity=1).count()
        xdata = [dataset.name.capitalize() for dataset in datasets]
        ydata = [dataset.apks.count() for dataset in datasets]
        chartdata = {'x': xdata, 'y': ydata}
        charttype = "pieChart"
        chartcontainer = 'piechart_container'
        data = {
            'charttype': charttype,
            'chartdata': chartdata,
            'chartcontainer': chartcontainer,
            'extra': {
                'x_is_date': False,
                'x_axis_format': '',
                'tag_script_js': True,
                'jquery_on_ready': False,
            }
        }
        context['data']=data
        context['goodware']=goodware
        context['malware']=malware
        return context

    def get_queryset(self):
        models = Model.objects.all ()
        for m in models:
            m.accuracy = (m.tp + m.tn) / (m.tp + m.tn + m.fp + m.fn)
            m.recall = m.tp / (m.tp + m.fn)
            m.precision = m.tp / (m.tp + m.fp)
            m.fpr = m.fp / (m.fp + m.tn)
            m.f1 = 2 * (m.precision * m.recall) / (m.precision + m.recall)
            m.positives = m.tp + m.fp
            m.negatives = m.tn + m.fn
            m.tpr = m.recall

        return models




class DrebinPage (TemplateView):
    template_name = "training_app/drebin.html"


# apprentissage module drebin
class DrebinTrainingView (FormView):
    template_name = 'training_app/drebin.html'
    form_class = DatasetsForm
    success_url = reverse_lazy ('training_app:thanks')
    validation_report = dict ()

    def form_valid(self, form):
        begnin_dataset = form.cleaned_data['list_begin_datasets']
        malware_dataset = form.cleaned_data['list_malware_datasets']
        messages.add_message (self.request, messages.INFO, 'training started')
        #validation_report = generate_model.generateModel (begnin_dataset=begnin_dataset,
         #                                                 malware_dataset=malware_dataset)
        #self.validation_report['result'] = validation_report
        return render (self.request, 'training_app/drebin_report.html')
                      # context={'validation_report': validation_report})


class DownloadModel (View):

    def get(self, request, *args, **kwargs):
        path_to_file = os.path.join (settings.MODELS_DIR,'model_1.sav')
        with open (path_to_file, 'rb') as file:
            response = HttpResponse (file, content_type='text/sav')
            response['Content-Disposition'] = 'attachment; filename=model_1.sav'
            return response

def downloadModelView(request,path):
    if os.path.exists (path):
        with open(path,'rb') as file:
            response=HttpResponse(file,content_type='text/sav')
            response['Content-Disposition']='attachement;filename=' + os.path.basename(path)
            return response
    raise Http404



class MessagesView (TemplateView):
    template_name = 'training_app/messages.html'


class ApkListView (ListView):
    context_object_name = 'apks'
    model = Apk
    paginate_by = 10
    form_class = SearchApkForm
    queryset = Apk.objects.order_by ('-id')
    template_name = "training_app/apks.html"

    def get_queryset(self):
        queryset = Apk.objects.all ().order_by ('-id')
        q = self.request.GET.get ('q', None)
        if q is not None:
            queryset = apk_search.search_for_apks (q).order_by ('-id')
        return queryset


class ApkDetailView (DetailView):
    context_object_name = 'apk_detail'
    model = Apk
    template_name = 'training_app/apk_detail.html'


# contruction d'un espace vectoriel
class VectorSpaceView (FormView):
    template_name = 'training_app/vector_space.html'
    form_class = VectorSpaceForm
    success_url = reverse_lazy ('training_app:vector_space')
    success_message = "L'espace vectoriel a été créé avec succès"

    def form_valid(self, form):
        datasets_name = form.cleaned_data['datasets']
        type_features = form.cleaned_data['type_features']
        rep_type = form.cleaned_data['rep_type']
        scal_type=form.cleaned_data['scal_type']
        # create the vector space and save it to the database
        vs,f=vectorizer.build_vector_space(dataset=datasets_name,type_feature=type_features,rep_type=rep_type,scal=scal_type)
        print('Nb features: ')
        messages.success (self.request, 'vs_success')
        return redirect ('training_app:vector_space')


# Sélection des domensions
class SelectDimensionsView (FormView):
    template_name = 'training_app/select_dimensions.html'
    form_class = SelectDimensionsForm
    success_url = reverse_lazy ('training_app:select_dimensions')

    def form_valid(self, form):
        datasets_name = form.cleaned_data['datasets']
        vs = form.cleaned_data['vs']
        nb_features = form.cleaned_data['nb_features']
        # apply Mean decrease impurity + create new vs

        messages.success (self.request, 'vs_success')
        return redirect ('training_app:select_dimensions')

# Apprentissage
class TrainModelView (FormView):
    template_name = 'training_app/train_model.html'
    form_class = TrainModelForm
    success_url = reverse_lazy ('training_app:select_dimensions')

    def form_valid(self, form):
        datasets = form.cleaned_data['datasets']
        type_cls = form.cleaned_data['type_cls']
        cv = form.cleaned_data['cv']
        vs = form.cleaned_data['vs']
        pca = form.cleaned_data['pca']
        score_index=form.cleaned_data['score']
        print('building vs')
        print(vs)
        vs_dict,vs_dict_inv=vectorizer.build_vector_space_dict(features=db_manager.get_vector_space_features(vs_id=vs))
        print ('constructing X,y')
        X, y = vectorizer.get_X_y_datasets (vector_space_dict=vs_dict, datasets=datasets)
        print ('Split')
        X_train, X_test, y_train, y_test = learner.train_test_split (X, y, shuffle=True, random_state=learner.RANDOM_STATE)
        n_samples = X_train.shape[0]
        print ('Training')
        hyper_params = learner.init_hyper_params (n_samples)
        classifiers = learner.init_classifier (n_samples)
        grid_search_result = learner.train_hyper_parameters (estimator=classifiers[type_cls], X_train=X_train, y_train=y_train,
                                                     nb_splits=cv, param_grid=hyper_params[type_cls], scorer=learner.scores[2])

        X_train, X_test, y_train, y_test = learner.train_test_split (X, y, random_state=learner.RANDOM_STATE)
        print ('Evaluation')
        validation_report=learner.evaluate(estimator=grid_search_result['best_estimator'],X_test=X_test,y_test=y_test)

        return render (self.request, 'training_app/model_report.html',
                context={'validation_report': validation_report})



class DatasetsListView(ListView):
    context_object_name = 'datasets'
    template_name = 'training_app/datasets.html'
    model = Dataset
    queryset = Dataset.objects.annotate (m=Sum ('apks__malignity'),t=Count('apks')).order_by('-id')



