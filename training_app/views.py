import os
from django.http import HttpResponse
from django.shortcuts import render
from django.urls import reverse_lazy
from django.contrib import messages
from django.shortcuts import redirect

from pfe_plateforme_web import settings
from django.views.generic import TemplateView, View, ListView, DetailView
from django.views.generic.edit import FormView
from training_app.forms import DatasetsForm, VectorSpaceForm, SelectDimensionsForm, TrainModelForm, SvmForm, RfForm, \
    KnnForm, StackingForm, BaggingForm, AdaboostForm, MlpForm, CnnForm
from main.forms import SearchApkForm
from main.search_engine import apk_search
from main.models import VectorSpace, Dataset, Apk, Feature
from formtools.wizard.views import SessionWizardView
from main.vector_space_constractor import vectorizer
import db_manager
import time
from training_app import learner


# Create your views here.
class ModelGenerationView (TemplateView):
    template_name = 'training_app/model_generation.html'

    def get_context_data(self, **kwargs):
        context = super ().get_context_data (**kwargs)
        #context['result'] = generate_model.generateModel ()
        return context


class HomePage (TemplateView):
    template_name = "training_app/dashboard.html"


class DrebinPage (TemplateView):
    template_name = "training_app/drebin.html"


# apprentissage module drebin
class DrebinTrainingView (FormView):
    template_name = 'training_app/drebin.html'
    form_class = DatasetsForm
    success_url = reverse_lazy ('training_app:thanks')
    validation_report = dict ()

    def form_valid(self, form):
        begnin_dataset = form.cleaned_data['list_begin_datasets']
        malware_dataset = form.cleaned_data['list_malware_datasets']
        messages.add_message (self.request, messages.INFO, 'training started')
        validation_report = generate_model.generateModel (begnin_dataset=begnin_dataset,
                                                          malware_dataset=malware_dataset)
        self.validation_report['result'] = validation_report
        return render (self.request, 'training_app/drebin_report.html',
                       context={'validation_report': validation_report})


class DownloadModel (View):

    def get(self, request, *args, **kwargs):
        path_to_file = os.path.join (settings.MODELS_DIR,'model_1.sav')
        with open (path_to_file, 'rb') as file:
            response = HttpResponse (file, content_type='text/sav')
            response['Content-Disposition'] = 'attachment; filename=model_1.sav'
            return response


class MessagesView (TemplateView):
    template_name = 'training_app/messages.html'


class ApkListView (ListView):
    context_object_name = 'apks'
    model = Apk
    paginate_by = 10
    form_class = SearchApkForm
    queryset = Apk.objects.order_by ('-id')
    template_name = "training_app/apks.html"

    def get_queryset(self):
        queryset = Apk.objects.all ().order_by ('-id')
        q = self.request.GET.get ('q', None)
        if q is not None:
            queryset = apk_search.search_for_apks (q).order_by ('-id')
        return queryset


class ApkDetailView (DetailView):
    context_object_name = 'apk_detail'
    model = Apk
    template_name = 'training_app/apk_detail.html'


# contruction d'un espace vectoriel
class VectorSpaceView (FormView):
    template_name = 'training_app/vector_space.html'
    form_class = VectorSpaceForm
    success_url = reverse_lazy ('training_app:vector_space')
    success_message = "L'espace vectoriel a été créé avec succès"

    def form_valid(self, form):
        datasets_name = form.cleaned_data['datasets']
        type_features = form.cleaned_data['type_features']
        rep_type = form.cleaned_data['rep_type']
        scal_type=form.cleaned_data['scal_type']
        # create the vector space and save it to the database
        vs,f=vectorizer.build_vector_space(dataset=datasets_name,type_feature=type_features,rep_type=rep_type,scal=scal_type)
        print('Nb features: ')
        messages.success (self.request, 'vs_success')
        return redirect ('training_app:vector_space')


# Sélection des domensions
class SelectDimensionsView (FormView):
    template_name = 'training_app/select_dimensions.html'
    form_class = SelectDimensionsForm
    success_url = reverse_lazy ('training_app:select_dimensions')

    def form_valid(self, form):
        datasets_name = form.cleaned_data['datasets']
        vs = form.cleaned_data['vs']
        nb_features = form.cleaned_data['nb_features']
        # apply Mean decrease impurity + create new vs

        messages.success (self.request, 'vs_success')
        return redirect ('training_app:select_dimensions')

# Apprentissage
class TrainModelView (FormView):
    template_name = 'training_app/train_model.html'
    form_class = TrainModelForm
    success_url = reverse_lazy ('training_app:select_dimensions')

    def form_valid(self, form):
        datasets = form.cleaned_data['datasets']
        type_cls = form.cleaned_data['type_cls']
        cv = form.cleaned_data['cv']
        vs = form.cleaned_data['vs']
        pca = form.cleaned_data['pca']
        score_index=form.cleaned_data['score']
        print('building vs')
        print(vs)
        vs_dict,vs_dict_inv=vectorizer.build_vector_space_dict(features=db_manager.get_vector_space_features(vs_id=vs))
        print ('constructing X,y')
        X, y = vectorizer.get_X_y_datasets (vector_space_dict=vs_dict, datasets=datasets)
        print ('Split')
        X_train, X_test, y_train, y_test = learner.train_test_split (X, y, shuffle=True, random_state=learner.RANDOM_STATE)
        n_samples = X_train.shape[0]
        print ('Training')
        hyper_params = learner.init_hyper_params (n_samples)
        classifiers = learner.init_classifier (n_samples)
        grid_search_result = learner.train_hyper_parameters (estimator=classifiers[type_cls], X_train=X_train, y_train=y_train,
                                                     nb_splits=cv, param_grid=hyper_params[type_cls], scorer=learner.scores[2])

        X_train, X_test, y_train, y_test = learner.train_test_split (X, y, random_state=learner.RANDOM_STATE)
        print ('Evaluation')
        validation_report=learner.evaluate(estimator=grid_search_result['best_estimator'],X_test=X_test,y_test=y_test)

        return render (self.request, 'training_app/model_report.html',
                context={'validation_report': validation_report})


# multiples steps form
def svm_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'svm'


def rf_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'rf'


def knn_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'knn'


def stacking_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'stacking'


def bagging_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'bagging'


def adaboost_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'adaboost'


def mlp_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'mlp'


def cnn_condition(wizard):
    cleaned_data = wizard.get_cleaned_data_for_step ('0') or {'type_cls': 'none'}
    return cleaned_data['type_cls'] == 'cnn'


class TrainModelWizard (SessionWizardView):
    template_name = 'training_app/train_model.html'
    form_list = [TrainModelForm]

    def done(self, form_list, **kwargs):
        # do something with form_list
        validation_report = {'accuracy': 0.96154742484269407,
                             'auc': 0.98631825016926544,
                             'f1': 0.96799224054316202,
                             'fn': 103,
                             'fp': 62,
                             'fpr': 0.03662138216184288,
                             'negatives': 1693,
                             'positives': 2598,
                             'precision': 0.97575283535393043,
                             'recall': 0.96035411855273289,
                             'tn': 1631,
                             'tp': 2495,
                             'tpr': 0.96035411855273289}

        return render (self.request, 'training_app/model_report.html',
                         context={'validation_report': validation_report})



