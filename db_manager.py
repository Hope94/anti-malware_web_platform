import os

import os
import time

from django.db.models import Sum, Count

from pfe_plateforme_web import settings

os.environ.setdefault ("DJANGO_SETTINGS_MODULE", "pfe_plateforme_web.settings")
import django

django.setup ()

from datashape import json
from django.db import transaction, connection
from typing import Union
from pfe_plateforme_web.settings import MODELS_DIR

from collections import defaultdict
from main.models import Apk, Feature, Extract, Dataset, Model, VectorSpace, DetectionResult, SuspiciousAPI


def vacuum():
    cursor = connection.cursor ()
    cursor.execute ("VACUUM;")
    transaction.commit ()


def settingSqlite():
    from django.db import connection
    cursor = connection.cursor ()
    cursor.execute ('PRAGMA temp_store = MEMORY;')
    cursor.execute ('PRAGMA synchronous=OFF')
    cursor.execute ("PRAGMA default_cache_size = 10000")


def insert_apk(info: dict, malignity=-1) -> Apk:
    if is_apk_in_db (info['sha256']):
        apk = get_apk_by_sha (info['sha256'])
    else:
        apk = Apk.objects.get_or_create (name=info['name']
                                         , malignity=malignity
                                         , package=info['package']
                                         , developer=info['developer']
                                         , displayed_version=info['displayed_version']
                                         , size=info['size']
                                         , md5=info['md5']
                                         , sha1=info['sha1']
                                         , sha256=info['sha256']
                                         , ssdeep=info['ssdeep']
                                         , target_sdk=info['targetsdk'])[0]
        apk.save ()

    return apk


def get_apk_dict_info(apk: Apk):
    return {
        'name': apk.name,
        'package': apk.package,
        'developer': apk.developer,
        'displayed_version': apk.displayed_version,
        'size': apk.size,
        'md5': apk.md5,
        'sha1': apk.sha1,
        'sha256': apk.sha256,
        'ssdeep': apk.ssdeep,
        'targetsdk': apk.target_sdk
    }


def insert_feature(name, type) -> Feature:
    feature = Feature.objects.get_or_create (name=name, type=type)[0]
    feature.save ()
    return feature


def is_extract_in_db(apk, feature):
    num_results = Extract.objects.filter (apk=apk, feature=feature).count ()
    return num_results != 0


def insert_extract(apk, feature, nb_feature) -> Extract:
    if (is_extract_in_db (apk=apk, feature=feature)):
        extract = Extract.objects.get (apk=apk, feature=feature)
    else:
        extract = Extract.objects.get_or_create (apk=apk, feature=feature, nb_feature=nb_feature)[0]
        extract.save ()
    return extract


def insert_apk_features(apk, list_features: list) -> Extract:
    list_extract = [
        Extract (apk=apk,
                 feature=item[0],
                 nb_feature=item[1]
                 )
        for item in list_features if not is_extract_in_db (apk=apk, feature=item[0])
    ]
    extract = Extract.objects.bulk_create (list_extract)
    return extract


def get_apk_record(apk_id: int) -> Apk:
    apk = Apk.objects.get (pk=apk_id)
    return apk


def get_apk_by_sha(sha256: int) -> Apk:
    return Apk.objects.get (sha256=sha256)


def get_apks() -> list:
    return [apk for apk in Apk.objects.all ()]


def get_dataset(name: str) -> Dataset:
    return Dataset.objects.get (name=name)


def get_datasets(datasets: list) -> list:
    _datasets = []
    for dataset in datasets:
        _datasets.append (Dataset.objects.get (name=dataset))
    return _datasets


def get_apk_features(apk_id: int) -> list:
    apk = Apk.objects.get (pk=apk_id)
    list_extract = apk.extractions.all ()
    # list_extract = Extract.objects.filter (apk=apk).all ()
    return [(e.feature, e.nb_feature) for e in list_extract]


def get_apk_features_ids(apk_id: int) -> dict:
    apk = Apk.objects.get (pk=apk_id)
    list_extract = apk.extractions.all ()
    return {e.feature.pk: e.nb_feature for e in list_extract}


def get_feature(type: str, name: str) -> Feature:
    return Feature.objects.get (name=name, type=type)


def get_apk_malignity(apk_name: str) -> int:
    apk = Apk.objects.get (name=apk_name)
    return apk.malignity


def get_datasets_apks(datasets: list) -> list:
    apks = Apk.objects.filter(datasets__name__in=datasets).distinct()
    return [(apk.pk, apk.malignity) for apk in apks.iterator(chunk_size=1000000)]

def get_apks_in_datasets(datasets: list) -> list:
    apks=Apk.objects.filter(datasets__name__in=datasets).distinct()
    return [(apk.pk,apk.malignity) for apk in apks.iterator(chunk_size=1000000)]


def is_apk_in_db(sha256) -> bool:
    num_results = Apk.objects.filter (sha256=sha256).count ()
    return num_results != 0


def add_apk_to_dataset(apk: Apk, dataset_name: str):
    dataset = Dataset.objects.get_or_create (name=dataset_name)[0]
    dataset.save ()
    apk.datasets.add (dataset)
    apk.save ()


def insert_model(name, path, type_cls, vs, auc, tp, tn, fp, fn):
    model = Model.objects.get_or_create (name=name, path=path, type_cls=type_cls, vs=vs, auc=auc, tp=tp, tn=tn, fp=fp, fn=fn)[0]
    model.save ()
    return model


def insert_vector_space(rep_type: str, scal: str):
    vs = VectorSpace.objects.get_or_create (representation_type=rep_type, scal=scal)[0]
    vs.save ()
    return vs


@transaction.atomic
def add_features_to_vs(vs: VectorSpace, features: list):
    for f in features:
        vs.features.add (f)
    vs.save ()


def is_detection_result_in_db(apk: Apk, model: Model):
    num_results = DetectionResult.objects.filter (apk=apk, model=model).count ()
    return num_results != 0


def insert_detection_result(prediction: bool, score: float, apk: Apk, model):
    if is_detection_result_in_db (apk=apk, model=model):
        res_detect = DetectionResult.objects.get (apk=apk, model=model)
    else:
        res_detect = DetectionResult.objects.get_or_create (prediction=prediction, score=score
                                                            , apk=apk, model=model)[0]
        res_detect.save ()
    return res_detect


def get_apk_detection_results(apk: Apk):
    return apk.detection_results


def get_models():
    return Model.objects.all ()


def get_vector_space_features(vs_id: int):
    vs = VectorSpace.objects.get (pk=vs_id)
    return vs.features.all ()


def get_datasets_features(datasets_name: list, type_features: list):
    features = list (Feature.objects.filter (extractions__apk__datasets__name__in=datasets_name,
                                             type__in=type_features).values_list ('pk', flat=True).distinct ())
    return features


def insert_ssdeep_targetsdk(apk: Apk, ssdeep, target_sdk):
    apk.ssdeep = ssdeep
    apk.target_sdk = target_sdk
    apk.save ()


def insert_family_name_to_apk(apk: Apk, family_name):
    apk.family_name = family_name
    apk.save ()


def is_suspicious(api: str) -> bool:
    num_results = SuspiciousAPI.objects.filter (api=api).count ()
    return num_results != 0


def get_suspicious_api() -> dict:
    suspicious_api_dict = defaultdict (lambda: False)
    for _api in SuspiciousAPI.objects.all ():
        suspicious_api_dict[_api.api] = True
    return suspicious_api_dict


'''
# slower version
def get_features_by_ids(list_ids):
    all_features=Feature.objects.all()
    filtered_features=[fe for fe in all_features if fe.id in list_ids]
    return filtered_features

'''
def get_all_types():
    return  [f['type'] for f in Feature.objects.values('type').distinct().iterator(chunk_size=100000)]


def get_features_by_ids(list_ids):
    features = Feature.objects.in_bulk (list_ids)
    return features


if __name__ == '__main__':
    goodware = Dataset.objects.filter (apks__malignity=0).count ()
    malware = Dataset.objects.filter (apks__malignity=1).count ()
    print(goodware)
    print(malware)

    import datetime
    import ufp.path

    print(ufp.path.unique ('./test.ext'))
    '''
    # create vs
    from training_app.learner import load_object


    list_ids=load_object('selected_features.pkl')
    start_time = time.time ()
    features=get_features_by_ids(list_ids)
    features_list=features.values()
    vs=insert_vector_space(rep_type='continue',scal='Standard Scaler')
    add_features_to_vs(vs=vs,features=features_list)
    print ("--- %s seconds ---" % (time.time () - start_time))    
    
    #create new model
    model_path=os.path.join(MODELS_DIR,'svm_model.sav')
    vs=VectorSpace.objects.get(representation_type='continue',scal='Standard Scaler')
    insert_model(path=model_path,name='Svm',type_cls='SVM',auc=0.9934840591540605,tp=7294,tn=1549,fp=143,fn=33,vs=vs)

    
    #insert_vector_space(rep_type=,)
        

    '''
