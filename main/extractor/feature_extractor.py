import os
import traceback
from main.extractor.utils import list_files, clean_baksmali_output_dir, APKS_JS_OUTPUT_PATH
from pfe_plateforme_web.settings import MEDIA_DIR, APK_DIR
from main.extractor.apis_manager import init_in_memory_all_permission_mappings,init_in_memory_suspicious
from main.extractor.feature_extractor_dex import extract_dex_features_api_level
from main.extractor.feature_extractor_manifest import extract_manifest_features,extract_features_using_androguard
from db_manager import insert_apk, insert_feature, insert_extract, add_apk_to_dataset,insert_apk_features,settingSqlite,is_apk_in_db
from main.extractor.apk_information_extractor import extract_info_apk
from django.db import transaction
import time
import json
MALWARE_DATASET_DIR_PATH = os.path.join (os.path.join(MEDIA_DIR,'Datasets_applications'), 'malwares')
BENIGN_DATASET_DIR_PATH = os.path.join (os.path.join(MEDIA_DIR,'Datasets_applications'), 'benign')



def analyse_apks(path: str, dataset_name: str, malignity: int, tool=2, in_memory=True,
                 ) -> int:
    list_path_apks = [apk_path for apk_path in list_files (path)]
    count = 0
    apks_number = len (list_path_apks)

    # load previous analysed apk in the file
    log_file = os.path.join(path,'log.json')
    with open(log_file, 'r') as fp:
        analysed_apk=json.load(fp)
    fp.close()

    error_log = open ('error_log.txt', 'w')
    if in_memory:
        init_in_memory_suspicious()
        init_in_memory_all_permission_mappings()

    for _apk in list_path_apks:
        if _apk not in analysed_apk.keys():
            try:
                t = time.time()
                apk,api_level = extract_apk(_apk , dataset_name, in_memory=True, tool=2, malignity=malignity)
                tf = time.time()
                count += 1
                print(apk.name + ' extracted .... ' + str(count) + '/' + str(apks_number))
                analysed_apk.update({_apk:[tf-t,api_level,apk.size]})
                if count in range (100,1200,20):
                    with open(log_file, 'w') as fp:
                        json.dump(analysed_apk, fp)
                    fp.close()
            except Exception as exception:
                print ('Error for APK ' + _apk)
                traceback.print_exc ()
                error_log.write('Error for APK ' + _apk + '\n')
        else:
            print('apk : '+ _apk+' already analysed \n')

    with open(log_file, 'w') as fp:
        json.dump(analysed_apk, fp)
    fp.close()
    error_log.write (' Apk extracted :' + str (count) + ' of total: ' + str (apks_number) + '\n')
    error_log.close ()
    return count

# @transaction.atomic
# def analyse_apks(path: str, dataset='dzplay', malignity=0
#                  ) -> int:
#     list_path_apks = [apk_path for apk_path in list_files(path)]
#     count = 0
#     apks_number = len (list_path_apks)
#     print(list_path_apks)
#     for _apk in list_path_apks:
#         # load previous analysed apk in the file
#         with open(_apk, 'r') as fp:
#             analysed_apk = json.load(fp)
#         fp.close()
#         info = analysed_apk['info']
#
#         apk = insert_apk (info=info,malignity=malignity)
#         add_apk_to_dataset (apk, dataset)
#
#         manifest_features = analysed_apk['manifest']
#         dex_features = analysed_apk['dex']
#
#         list_features=[]
#         for type in manifest_features:
#             for name in manifest_features[type]:
#                 f = insert_feature (name=name, type=type)
#                 list_features.append((f,manifest_features[type][name]))
#         for type in dex_features:
#             for name in dex_features[type]:
#                 f = insert_feature (name=name, type=type)
#                 list_features.append ((f, dex_features[type][name]))
#         insert_apk_features(apk,list_features)
#         count += 1
#         print(_apk + ' extracted .... ' + str(count) + '/' + str(apks_number))
#
#
#
#     return count

# by using bulk_create function
@transaction.atomic
def extract_apk(path: str, dataset: str, in_memory=True, tool=2, malignity=-1):

    info , androguard = extract_info_apk(path_to_apk=path)
    api_level = androguard.get_effective_target_sdk_version()
    target_api = api_level
    if api_level<16:
        api_level=16
    apk = insert_apk (info=info,malignity=malignity)
    add_apk_to_dataset (apk, dataset)
    manifest_features = extract_features_using_androguard(androguard)
    dex_features = extract_dex_features_api_level (path,api_level,True)
    list_features=[]
    for type in manifest_features:
        for name in manifest_features[type]:
            f = insert_feature (name=name, type=type)
            list_features.append((f,manifest_features[type][name]))
    for type in dex_features:
        for name in dex_features[type]:
            f = insert_feature (name=name, type=type)
            list_features.append ((f, dex_features[type][name]))
    insert_apk_features(apk,list_features)
    return apk,target_api



# app_name = "6c6eeed1b91913db0d6232edb1979c67d6fb48ca3da4f83dc49fb565a4e5f4fe.apk"
# init_in_memory_suspicious()
# init_in_memory_all_permission_mappings()
# path_to_apk = os.path.join (APK_DIR, app_name)
#init_in_memory_dicts()


'''
start_time = time.time ()
# extract_apk(path_to_apk,dataset='user',in_memory=True,tool=2,malignity=-1)
# DREBIN = os.path.join(MALWARE_DATASET_DIR_PATH,'drebin_dataset')
# DZPLAY = os.path.join(MALWARE_DATASET_DIR_PATH,'dzplay_malwares')
# part = os.path.join(DREBIN,'drebin-0')
AMD_DATASET_DIR_PATH = os.path.join (os.path.join(MEDIA_DIR,'amd_data'), 'Airpush')
AMD = os.path.join(AMD_DATASET_DIR_PATH,'variety1')

# analyse_apks(os.path.join(BENIGN_DATASET_DIR_PATH,'dzplay'), dataset='dzplay', malignity=0)
analyse_apks (AMD, dataset_name='airpush', malignity=1, tool=2, in_memory=True)
print ("--- %s seconds ---" % (time.time () - start_time))
'''


